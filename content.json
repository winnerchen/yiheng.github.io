{"meta":{"title":"Chen's Blog","subtitle":null,"description":null,"author":"Yiheng Chen","url":"https://winnerchen.github.io"},"pages":[{"title":"","date":"2022-06-11T08:38:56.003Z","updated":"2022-06-11T08:38:56.003Z","comments":true,"path":"script.js","permalink":"https://winnerchen.github.io/script.js","excerpt":"","text":"/*============================================================= Authour URI: www.binarytheme.com License: Commons Attribution 3.0 http://creativecommons.org/licenses/by/3.0/ 100% To use For Personal And Commercial Use. IN EXCHANGE JUST GIVE US CREDITS AND TELL YOUR FRIENDS ABOUT US ======================================================== */ (function ($) { \"use strict\"; var mainApp = { main_fun: function () { /*==================================== CUSTOM LINKS SCROLLING FUNCTION ======================================*/ $('nav a[href*=#]').click(function () { if (location.pathname.replace(/^\\//, '') == this.pathname.replace(/^\\//, '') && location.hostname == this.hostname) { var $target = $(this.hash); $target = $target.length && $target || $('[name=' + this.hash.slice(1) + ']'); if ($target.length) { var targetOffset = $target.offset().top; $('html,body') .animate({ scrollTop: targetOffset }, 800); //set scroll speed here return false; } } }); /*==================================== NAV SCRIPTS ======================================*/ $(window).bind('scroll', function () { var navHeight = $(window).height() -50; if ($(window).scrollTop() > navHeight) { $('nav').addClass('fixed'); } else { $('nav').removeClass('fixed'); } }); }, initialization: function () { mainApp.main_fun(); } } // Initializing /// $(document).ready(function () { mainApp.main_fun(); }); }(jQuery));"},{"title":"关于","date":"2017-08-11T11:55:44.000Z","updated":"2022-06-11T08:38:55.977Z","comments":true,"path":"about/index.html","permalink":"https://winnerchen.github.io/about/index.html","excerpt":"","text":"陈逸恒Java开发工程师 raily@live.cnGitHub主页：https://github.com/winnerchen"},{"title":"分类","date":"2017-08-11T11:54:53.000Z","updated":"2022-06-11T08:38:55.978Z","comments":false,"path":"categories/index.html","permalink":"https://winnerchen.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-08-11T11:55:35.000Z","updated":"2022-06-11T08:38:56.003Z","comments":false,"path":"tags/index.html","permalink":"https://winnerchen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Developing On AWS","slug":"developing-on-aws","date":"2019-11-25T05:20:55.000Z","updated":"2022-06-11T08:38:55.971Z","comments":true,"path":"2019/11/25/developing-on-aws/","link":"","permalink":"https://winnerchen.github.io/2019/11/25/developing-on-aws/","excerpt":"Course StructureFundamentals for 3-tier web apps Cloud Compute IAM EC2 ELB ROUTE 53 Data Store RDS ElastiCache Object Storage S3","text":"Course StructureFundamentals for 3-tier web apps Cloud Compute IAM EC2 ELB ROUTE 53 Data Store RDS ElastiCache Object Storage S3 Developer tools AWS CLI Python SDK Node.js IAM CI/CD with monitoring and infrastructure as code Elastic Beanstalk AWS CodeCommit CodeBuild CodeDeploy CodePipeline CloudFormation CloudWatch CloudTrail X-Ray Application decoupling &amp; integration SQS SNS Kinesis Servless paradigm Lambda Dynamodb Dynamodb accelerator API Gateway Coginto SAM AWS fundamentals: IAM+EC2IAM users usually a physical person Groups Contains users users in the group inherits permission attached to this group Roles Internal usage within AWS resources Policies define permissions IAM has global view Permissions are governed by Policies Least privilege principles - IAM 101 One IAM User per physical person One IAM role per application IAM credentials should never be shared Never write IAM credentials in code Never use the root account except for initial setup Never use ROOT IAM credentials Security Groups they control how traffic is allowed into or out of our EC2 machines Acts as a firewall on EC2 instances They regulate: Access to Ports authorised IP ranges - ipv4 and ipv6 control of inbound network control of outbound network Good to know about security groups can be attached to multiple instances one ec2 instance can attach to multiple security group locked down to a region/vpc combination live outside of the ec2 - if traffice is blocked the ec2 instance won’t see it it’s good to maintain one separate security group for SSH access if your application is not accessible, then it’s a security group issue if your application gives a ‘connection refused’ error, then it’s an application error or it’s not launched all inbound traffic is blocked by default all outbound traffice is authorised by default a security group can reference to another security group and authorise instances that attach to the right security group to access Private vs Public IP by default, your ec2 machine comes with a private ip for the internal AWS network a public ip, for the www when we are doing SSH into our EC2 machines we can only use the public ip If your machine is stopped and restarted, the public IP can change EC2 User Data Bootstrap script that allow you to run custom commands when a instance is launched It is only run once at the instance first started Used to automate boot tasks such as: Installing updates installing software Downloading common files from the internet Anything you can think of The ec2 user data scrip runs with the root privilege. EC2 Instance Launce Types On Demand Instance: short work load, predictable pricing pay for what you use has the highest rate but no upfront payment no long term commitment Reserved Instances: long workloads (&gt;= 1 year) up to 75% discount compared to on-demand pay upfront for what you use with long term commitment reservation period can be 1 or 3 years reserve a specific instance type recommended for steady state usage application (think of database) Convertible Reserved Instance: long workloads with flexible instances can change the EC2 instance type up to 54% discount Scheduled Reserved Instances: launch within time window you reserve Spot Instance: short workloads, for cheap, can lose instances can get a discount of up to 90% compared to on-demand you bid a price and get the instance as long as its under the price price varies based on offer and demand spot instances are reclaimed with a 2 minute notification warning when the spot price goes above your bid used for batch jobs, Big Data analysis, or workloads that are resilient to failures not great for critical services Dedicated Instances: no other customers will share your hardware instances running on hardware that’s dedicated to you may share hardware with other instances in same account no control over instance placement (can move hardware after stop/start) Dedicated Hosts: book an entire physical server, control instance placement physical dedicated ec2 server for your use full control of ec2 instance placement visibility into the underlying sockets/physical cores of the hardware allocated for your account for a 3 year period reservation more expensive useful for software that have complicated licensing model or for companies that have strong regulatory or compliance needs EC2 Pricing Pricing parameters (per hour): region Instance Type Operating system billed by the second, with a minimum of 60 seconds. you do not pay for the instance if the instance is stopped what is","categories":[],"tags":[]},{"title":"Deep Dive Into Java8 Stream","slug":"deep-dive-into-java8-stream","date":"2019-11-13T23:56:28.000Z","updated":"2022-06-11T08:38:55.971Z","comments":true,"path":"2019/11/14/deep-dive-into-java8-stream/","link":"","permalink":"https://winnerchen.github.io/2019/11/14/deep-dive-into-java8-stream/","excerpt":"What is stream Before we start, let’s image a scenario where you have a collection of apples and you want to filter them by their weight, and you only want to keep apples that are more than 100 grams, how would you do it? Before Java8 and Stream was introduced, you might write code like this to iterate over the collection and store the ones that match the condition to another list. 12345678910public List&lt;Apple&gt; filterByWeight(List&lt;apple&gt; apples, int weight)&#123; List&lt;Apple&gt; filteredApples = new ArrayList&lt;&gt;(); for (Apple apple : apples)&#123; if(apple.weight &gt; weight)&#123; filteredApples.add(apple); &#125; &#125; return filteredApples;&#125;","text":"What is stream Before we start, let’s image a scenario where you have a collection of apples and you want to filter them by their weight, and you only want to keep apples that are more than 100 grams, how would you do it? Before Java8 and Stream was introduced, you might write code like this to iterate over the collection and store the ones that match the condition to another list. 12345678910public List&lt;Apple&gt; filterByWeight(List&lt;apple&gt; apples, int weight)&#123; List&lt;Apple&gt; filteredApples = new ArrayList&lt;&gt;(); for (Apple apple : apples)&#123; if(apple.weight &gt; weight)&#123; filteredApples.add(apple); &#125; &#125; return filteredApples;&#125; Client code which invokes this method would be like this: 1List&lt;Apple&gt; filteredApples = filterByWeight(apples,100) The above code complies and runs perfectly fine and it might also be effective. Now let’s take a look at what we can achieve with the help of Stream. 1List&lt;Apple&gt; filteredApples = apples.stream().filter(e-&gt; e.weight&gt;100).collect(toList()); Yes, that’s right. With the help of stream we are able to reduce the number of lines of code from about 10 to 1. But let’s take a closer look at both implementations, and try to understand the key difference and what’s really important. The first implementation, we tell program how to iterate over our collection and how it should perform in each iteration. We call this Imperative Programming, in which you tell what to do. The second implementation, we tell the program what we what to achieve, and the underlying implemenation will take care of the iteration logic. This is what we call declarative programming. So what’s so good about writing code in a declarative way? It is more flexible - more adaptive to requirement changes if we want to filter apples by it’s price, without stream we will have to implement a new method which iterate over the collection of apples and filter them by price. with stream we can simply replace the lambda express which define what we want to perform on this collection, e.g.1List&lt;Apple&gt; filteredApples = apples.stream().filter(e-&gt; e.price &gt; 2.5).collect(toList()); It is clearer and more consice Is is more readable and hence easier to maintain Now let’s get back to the topic, what is Stream really? For starters, Streams are an update to the Java API that lets you manipulate collections of data in a declarative way (you express a query rather than code an ad hoc implementation for it), so for now you can think of them as fancy iterators over a collection of data. Stream gives us the ability to write code that’s Declarative— More concise and readable Composable— Greater flexibility Parallelizable— Better performance Get started with streamsLet’s look at a bit more complicated example, get the names of the first three dishes which calories is higher than 300. Take a look at the following code that’s implemented using Stream api. 12345List&lt;String&gt; threeHighCaloricDishNames = menu.stream() .filter(e -&gt; e.getCalories &gt; 300) .map (Dish::getName) .limit(3). .collect(toList()); Imagine you have to implement this using external iteration (for loops), and compare to above implementation, you can already see the advantages of using streams. The code we’ve just written is very clear and descriptive, it tells us and the machine exactly what needs to be done, “find the names of the first 3 dishes which has calories higher than 300”. Rather than implementing the functionalities, we simply tell the program what needs to be done, and as a result, the program has more flexibility to decide how to optimize the pipeline processing. e.g. all the operation can be merged in to one and stop as soon as 3 matched dishes is found. Common Stream APIThe Stream interface defines many operations and they can be classified into two categories, namely intermediate operation and terminal operations Intermediate operation - any operation that returns a stream is a intermediate operation Terminal operation - any operation that closes a stream is a terminal operation Intermediate operation filter - expecting a predicate (take one arguement and return a boolean), filter out elements that does not match the predicate map - extract distinct sorted peek limit Intermediate operation forEach reduce count anyMatch","categories":[{"name":"Coding","slug":"Coding","permalink":"https://winnerchen.github.io/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"https://winnerchen.github.io/tags/java/"},{"name":"java 8","slug":"java-8","permalink":"https://winnerchen.github.io/tags/java-8/"},{"name":"stream","slug":"stream","permalink":"https://winnerchen.github.io/tags/stream/"}]},{"title":"Teamcity quickstart","slug":"Teamcity-quickstart","date":"2018-01-19T23:01:30.000Z","updated":"2022-06-11T08:38:55.971Z","comments":true,"path":"2018/01/20/Teamcity-quickstart/","link":"","permalink":"https://winnerchen.github.io/2018/01/20/Teamcity-quickstart/","excerpt":"前言Teamcity是由JetBrain公司开发的一个强大的持续集成工具，支持多个平台、环境和语言。在深入了解Teamcity之前，需要先了解持续集成（Continuous Integration）这个概念。不熟悉的同学们请移步： 百科定义：http://baike.baidu.com/view/5253255.htm 网络文章：http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html","text":"前言Teamcity是由JetBrain公司开发的一个强大的持续集成工具，支持多个平台、环境和语言。在深入了解Teamcity之前，需要先了解持续集成（Continuous Integration）这个概念。不熟悉的同学们请移步： 百科定义：http://baike.baidu.com/view/5253255.htm 网络文章：http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html TeamCity入门TeamCity安装部署略 TeamCity相关配置添加项目 在主页点击右上角的Administration进当如下图所示的项目管理界面，然后点击Create Project。 如下所示，进入添加项目界面后有多个添加项目的方式。本人所有项目都是从github上添加进来的。项目添加完毕之后可以对项目进行管理，配置构建程序。 配置构建步骤进入项目管理界面之后，在Build Configurations这一栏里找到Build Step。这里就是需要你配置自定义构建程序的地方了。由于teamcity支持maven，意味着可以直接在teamcity中运行所有maven的指令，这包括了clean,complie,deploy,install等等。还支持maven插件下的tomcat项目部署。 点击edit进入下图，这个是构建步骤页面，在这里可以进行相关的配置Build Step页面如下图所示（核心配置） 点击edit进入具体的每个构建步骤的详细配置，如下图所示。 上面提到了Teamcity支持所有的maven指令，还包括maven的插件。这意味着我们可以通过maven来部署我们的项目。上面那个构建步骤是编译和打包整个项目，下面则是如何部署项目相关的配置。详细配置如下图所示","categories":[],"tags":[]},{"title":"Spring QuickStart","slug":"Spring-Introduction","date":"2017-10-19T07:37:02.000Z","updated":"2022-06-11T08:38:55.971Z","comments":true,"path":"2017/10/19/Spring-Introduction/","link":"","permalink":"https://winnerchen.github.io/2017/10/19/Spring-Introduction/","excerpt":"1. Introduction1.1 What is SpringThe Spring Framework is an open-source application framework that is hierarchical, full-stack and lightweight. 1.1.1 JavaEE HierarchyThree-layer structural system of JavaEE standard: Presentation Layer(display of webpage data, navigation and dispatch of webpage), e.g. Jsp/Servlet. Business Logic Layer(business process, function logics and transaction control), e.g. service Data Presistence Layer(data access and encapuslation, interaction with database), e.g. dao","text":"1. Introduction1.1 What is SpringThe Spring Framework is an open-source application framework that is hierarchical, full-stack and lightweight. 1.1.1 JavaEE HierarchyThree-layer structural system of JavaEE standard: Presentation Layer(display of webpage data, navigation and dispatch of webpage), e.g. Jsp/Servlet. Business Logic Layer(business process, function logics and transaction control), e.g. service Data Presistence Layer(data access and encapuslation, interaction with database), e.g. dao They are illustrated in below image. 1.1.2 Full Stack:Spring Framework provides solutions for all JavaEE layers Presentation Layer: Struts2, SpringMVC Business Logic Layer: IOC, AOP, Transaction control Data Presistence Layer（JDBCTemplate, HibernateTemplate, ORM framework integration) 1.1.3 Lightweight:The introduction of Spring has replaced its previous framework, EJB, which is inefficient, cumbersome and complex.Not to mention that using Spring to program is non-invasive. 1.2 System Architecture of SpringThe Spring framework is a hierarchical architecture that contains a set of functional elements and is divided into about 20 modules. These modules are Core Container, Data Access/Integration, WEB, AOP(Aspect Oriented Programming), Instrumentation and testing part, as shown in below figure: 1.2.1 Core Container It includes 4 modules: Core, Beans, Context and Express Language Core and Beans module provide the most fundamental functions of Spring: IoC(Inversion of control) and DI(Dependency Injection). The basic concept here is BeanFactory, which provides a classic implementation of the Factory pattern to eliminate the need for singleton patterns and utimately allows you to separate dependencies and configurations from program logic. The Context module is built on Core and Beans module, which provides the function of accessing to objects in a framework style. The Context wrapper inherits the functionality of beans package, which also includes internationalization(I18N), event propagation, resource loading, and transparent construct contexts, as well as support for a large number of JavaEE features such as EJB and JMX. It’s core interface is ApplicationContext. The Expression Language module provides the ability to query and manipulate object graphs during runtime. It supports access and modification for attribute values, arrays, containers and indexers. It also provides support for arithmetic and logical operations, list projections, selection and general list aggregation, as well as support for object access from Spring container. 1.2.2 Data Access/Integration JDBC module provides an abstraction of JDBC that eliminates the lengthy JDBC encoding and parsing database vendor-specific error code. ORM module provides an integrated layer of commonly used “object / relational” mapping APIs, including JPA, JDO, Hibernate and iBatis. With the ORM package, you can mix all the features provided by Spring to support “object/relation”mappings, such as simple declarative transaction management. Jms module provides a set of “message producer/consumer” template to simplify the use of Jms. JMS is employed between two applications, or sending message in distributive system to implement asynchronous communication. Transaction module provides support for simple declarative transaction management. Objects that are managed by Spring can all benefit from Spring transaction management, even it is a POJO e.g. Spring can also provide transaction control to POJO. 1.2.3 Web Web module provides fundamental web functions, such as multi-file upload, integration of IoC container, remote process access, and support for Web Service. It also provides a RestTemplate class to improve the convenience of Restful services access. Web-Servlet module provides a Model-View-Controller (MVC) implementation for Web applications. The Spring MVC framework provides annotation-based request resource injection, simpler data binding, data validation, and a set of easy-to-use JSP tags that work seamlessly with other Spring technologies. Web-Struts module provides support for Struts integration, this feature is not recommended in the Spring3.0, it is recommended that you should transfer to Struts2.0 or Spring MVC. Web-Protlet module provides the implementation under Portlet environment. 1.2.4 AOP The AOP module provides an aspect-oriented programming implementation that conforms to the AOP alliance specification so that you can define method interceptors and cutting points. Logically, it can reduce the code coupling so that functions be clearly separated. Moreover, the use of source-level metadata function, you can also combine a variety of behavioral information into your code. The Aspect module provides integration for AspectJ The Instrumentation module provides tool support for class-level and implementation for ClassLoader-level that can be used in some specific application servers. 1.2.5 Test The Test module provides support for testing Spring components using JUnit and TestNG, which provide consistent ApplicationContexts to cache these contexts. It also provides some mock objects that allow you to test your code independently. 1.3 The core of Spring IoC(Inversion of control): Handover the management of objects to Spring factory. AOP(Aspect Oriented Programming): Functional enhancement based on dynamic proxy 1.4 The advantages of SpringThe introduction of Spring aims to solve the practical issues of JavaEE: Remove dependency and simplify development Spring is a large factory that can manage the creation and dependency maintenance of any objects Support for AOP Spring provides support for AOP, which can easily implement functions such as access control, runtime monitoring, logging and etc. Support for declarative transaction control Implement the management of transaction by configuration file, without manual program. More convenient program testing Spring provides support for JUnit4, which allows us to test Spring program conveniently by annotation. Provide integration for a variety of excellent frameworks Spring does not exclude other well designed open source framework. It provides direct support for other excellent framework such as Struts2, Hibernate, MyBatis, Quartz, etc. Reduce the complexity of using JavaEE API Spring provides encapsulation for APIs that are difficult to use during JavaEE development, such as JDBC, JavaMail, remote method invocation, etc. 2. Spring IoC quick startBasic development procedure of Spring core context Download development package, import jar Coding Write configuration file 2.1 Coding2.1.1 Traditional Business logic coding (business layer, data persistence layer)The example I use here is simulation of user login operation Create interface IUserDao 1234567public interface IUserDao &#123; //query data from database according to username and password public void findByUsernameAndPassword();&#125; Create implementation class of interface IUserDao 1234567//Implementation class of daopublic class UserDaoImpl implements IUserDao &#123; @Override public void findByUsernameAndPassword() &#123; System.out.println(\"function findUserByUsernameAndPassword of UserDaoImpl has been called...\"); &#125;&#125; Create interface IUserService 12345//business layerpublic interface IUserService &#123; //login public void login();&#125; Create implementation class of interface IUserService 12345678910//Business layer implementationpublic class UserServiceImpl implements IUserService&#123; public void login() &#123; System.out.println(\"UserServiceImpl_login function has been called...\"); //instantiate dao IUserDao userDao = new UserDaoImpl(); userDao.findByUsernameAndPassword(); &#125;&#125; Test 12345678910public class SpringTest &#123; @Test public void test()&#123; //create service instance IUserService userService = new UserServiceImpl(); userService.login(); &#125; &#125; Console: In the example above, we are instantiating UserDaoImpl in UserServiceImpl class, which mean this class directly depends on UserDaoImpl class.This would cause many issues, e.g. error would occur if we want to change the implementation class, or rename the implementation class. It means that we will have to modify original code. Solution: Inversion of Control 2.2 Implementation of IoCUsing IoC (Inverse of Control) to solve the problem of code coupling. In one word, we introduce facotry that manage the object relations instead of manually create dependencies. Create a factory that provide userDao instanceUserDaoFactory.java 1234567public class UserDAOFactory &#123; //provide function to get object public UserDAOImpl getUserDAO()&#123; //return this instance return new UserDAOImpl (); &#125;&#125; Modify the code in UserServiceImpl 123456789public class UserServiceImpl implements IUserService&#123; public void login() &#123; System.out.println(\"UserServiceImpl_login function has been called...\"); //Create factory, get dependency from it UserDAOFactory userDAOFactory = new UserDAOFactory(); UserDAOImpl userDAO = userDAOFactory.getUserDAO(); userDAO.findUserByUsernameAndPassword(); &#125;&#125; Above method does solve code coupling between these two class. However, the function in factory class still requires a specific instance. The solution here is reflection. Solution: Create instance of object by reflection, which pass in a string that specify the dependency class UserDAOFactory.java:12345678910public Object getBean()&#123; Object bean = null; try &#123; bean = Class.forName(\"yiheng.chen.spring.a_quickstart.UserDAOImpl\").newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //return the instance return bean;&#125; UserServiceImpl.java:12IUserDAO userDAO = (IUserDAO) userDAOFactory.getBean();userDAO.findUserByUsernameAndPassword(); Let’s think,above solution use a fixed string to create instance, so how can we dynamically pass in different string? The solution is XML configuration file It comes to an end that the IoC underlying implementation is a combination of factory(design pattern), reflection(mechanism),and configuration file(XML). 2.3 Obtain Bean objects from Spring factory Configure applicationContext.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;bean id=\"userDAO\" class=\"yiheng.chen.spring.a_quickstart.UserDAOImpl\" /&gt;&lt;/beans&gt; Modify the code in UserServiceImpl class 1234//Create Spring factory, load Spring configuration file ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); IUserDAO userDAO = (IUserDAO) ac.getBean(\"userDAO\"); userDAO.findUserByUsernameAndPassword(); 2.4 Implementation of DIDI(Dependency Injection): When Spring framework is creating Bean object, it injects dependencies into bean components. Configure applicationContext.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;bean id=\"userDAO\" class=\"yiheng.chen.spring.a_quickstart.UserDAOImpl\" /&gt;&lt;bean id =\"userService\" class=\"yiheng.chen.spring.a_quickstart.UserServiceImpl\"&gt; &lt;!-- Inject object --&gt; &lt;!-- property inject dependency based on the setter function of the class --&gt; &lt;!-- ref: the object that it is refer to, its values is the id/name of that bean --&gt; &lt;property name=\"userDAO\" ref=\"userDAO\" /&gt;&lt;/bean&gt;&lt;/beans&gt; Provide setter functionUserServiceImpl.java 123456789101112131415public class UserServiceImpl implements IUserService&#123; //define attribute private IUserDAO userDAO; public void setUserDAO(IUserDAO userDAO) &#123; this.userDAO = userDAO; &#125; public void login() &#123; System.out.println(\"UserServiceImpl-service层方法调用了\"); userDAO.findUserByUsernameAndPassword(); &#125; Run test(the object must be obtained from Spring factory. Object that is mannually instantiated has no dependency injection) 1234567891011public class SpringTest &#123; @Test public void test()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); IUserService userService = (IUserService) ac.getBean(\"userService\"); userService.login(); &#125; &#125; 2.5 Spring FactoryApplicationContext is used to load Spring framework configuration file, to create Spring factory object. It is also known as Spring container. Why don’t we just use the top interface to operate? BeanFactory uses lazy load strategy, it initialize bean after user first call getBean function. ApplicationContext is an extension of BeanFactory which provides more functions. Internationalization(I18N) Event propagation Bean autowire Context implementation of different application layer Since ApplicationContext is much more powerful, it is rare to see BeanFactory used in development. PS. There is a difference between BeanFactory and FactoryBean. We will discuss it later. There are two ways of obtaining beans from IoC container by its id/name by the its class or the class of its interface 3. Assemble bean in IoC container3.1 Four ways of instantiating Bean Use default constructor(most common) Static factory method Define bean class Define factory Class and write static function to return the bean Configure applicationContext.xml, specify class and factory-method Instance factory method Define bean Define factory class and write non-static function to return the bean Configure applicationContext.xml, specify class of the factory, and factory-method and factory-bean of that bean FactoryBean Define bean Create MyFactoryBean class and implement FactoryBean interface Configure applicationContext.xm What is the difference between FactoryBean and BeanFactory? BeanFactory is a factory, it actually create the environment for Spring context. it is used to manage bean instance. FactoryBean is a tool which generates beans. It is a bean that we use to obtain a specific type of object. It is one way to instantiate bean instance. 3.2 Scope of Bean We normally use Singleton and Prototype in the project development. 3.3 The life cycle of beanWe are able to control the life cycle of bean through Spring factory 3.3.1 Configure init and destory function of bean Specify the function that will be invoked after instantiation by specifying init-method Specify the function that will be invoked after the object is destory by specifying destory-method Steps: Create LifeCycleBean, specify an init function and a destory function 123456789101112131415161718public class LifeCycleBean &#123; //define constructor public LifeCycleBean() &#123; System.out.println(\"LifeCycleBean constructor is called\"); &#125; public void init()&#123; System.out.println(\"LifeCycleBean-init, called after instantiation\"); &#125; public void destroy()&#123; System.out.println(\"LifeCycleBean-destroy called when object is destory\"); &#125;&#125; Configure applicationContext.xml 1&lt;bean id=\"lifeCycleBean\" class=\"yiheng.chen.spring.d_xmllifecycle.LifeCycleBean\" init-method=\"init\" destroy-method=\"destroy\" /&gt; 3.4 Dependency injection of bean attributeWhat is attribute injection of bean? It means assigning values to the attributes of an object. There are two ways of doing that: by passing the parameters in the constructor by using setter function 3.4.1 Attribute injection by constructor Define bean and its constructor 1234567891011121314151617public class Car &#123; private Integer id; private String name; private Double price; //Constructor with arguements public Car(Integer id, String name, Double price) &#123; this.id = id; this.name = name; this.price = price; &#125; @Override public String toString() &#123; return \"Car [id=\" + id + \", name=\" + name + \", price=\" + price + \"]\"; &#125;&#125; Configure applicationContext.xml 1234567891011121314151617181920&lt;!-- use constructor to inject values into attributes--&gt; &lt;bean id=\"car\" class=\"yiheng.chen.spring.e_xmlpropertydi.Car\"&gt; &lt;!--constructor-arg：indicate that we are using constructor with arguements instead of the default one new Car(1,\"BMW\",99999d) 1st group of parameters：locate attribute * index:locate attribute by index，0 means the first one * name：locate attribute by its name * type:locate attribute by its data type 2nd group of paramters：values * value:simple values, strings * ref: bean objects that are created by spring containter --&gt; &lt;!-- &lt;constructor-arg index=\"0\" value=\"1\"/&gt; --&gt; &lt;constructor-arg index=\"0\" name=\"id\" value=\"1\"/&gt; &lt;!-- &lt;constructor-arg name=\"name\" value=\"BMW_X3\"/&gt; --&gt; &lt;constructor-arg name=\"name\" &gt; &lt;value&gt;BMW_X6&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=\"java.lang.Double\" value=\"99999d\"/&gt; &lt;/bean&gt; 3.4.2 Attribute injection by setterIt uses the default constructor, however it must be provided by setter function. This method is commonly used in enterprise Java development Create java bean, define attributes 123456789101112131415161718192021public class Person &#123; private Integer id; private String name; private Car car; public void setId(Integer id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return \"Person [id=\" + id + \", name=\" + name + \", car=\" + car + \"]\"; &#125;&#125; Configure Spring container 12345&lt;bean id=\"person\" class=\"yiheng.chen.spring.e_xmlpropertydi.Person\"&gt; &lt;property name=\"id\" value=\"1001\"/&gt; &lt;property name=\"name\" value=\"Tom\"/&gt; &lt;property name=\"car\" ref=\"car\"/&gt; &lt;/bean&gt;","categories":[],"tags":[]},{"title":"Implement your own HashMap","slug":"Implement-your-own-hashmap","date":"2017-09-05T04:37:44.000Z","updated":"2022-06-11T08:38:55.970Z","comments":true,"path":"2017/09/05/Implement-your-own-hashmap/","link":"","permalink":"https://winnerchen.github.io/2017/09/05/Implement-your-own-hashmap/","excerpt":"1. IntroductionAs one of the important members of data structure in Java, HashMap has high performance in both insertion and query. Recently, I have learnt to know its power when I was working on the project. HashMap provides both high flexibility and scalability for font and back end data interactions that cannot be replaced by other data structures. Its key-value pair structure naturally provides good support for Json transformation. This article mainly analysis the theory of HashMap and how to implement your own HashMap.","text":"1. IntroductionAs one of the important members of data structure in Java, HashMap has high performance in both insertion and query. Recently, I have learnt to know its power when I was working on the project. HashMap provides both high flexibility and scalability for font and back end data interactions that cannot be replaced by other data structures. Its key-value pair structure naturally provides good support for Json transformation. This article mainly analysis the theory of HashMap and how to implement your own HashMap. 2. Theory of HashMap2.1 What is HashMap？In computing, a hash table (hash map) is a data structure which implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. – From Wikipedia, the free encyclopedia 2.2 What is hashHash is an algorithm, which can map a binary value with random length to a binary value with fixed length. In a HashMap, hash algorithm is mainly used to calculate the index that its value needs to be stored in. In one word, the storage process of a value is based on the hash value of its key. The performance of a hash algorithm depends on whether it can store data into an array with good distribution so that collisions can be avoided. There are many hash functions existed, and I will take division method as an example. First, define the length of an array, 16 for example (16 is also the default length of HashMap in JDK). Therefore, the index should be key mod m, and the value of m should be the maximum prime number that is less than the length of the array.m is therefore is 13 in this case. Such algorithm would lead to situation like this: we might get same index for different given keys. If that’s the case, we need to handle collisions. Ps. The hash algorithm in JDK is much more complicated. The example above is just an example for readers to understand more easily. 2.3 Handling collisionsThere are many solutions to handle collisions, and in this article I will introduce two methods and I will demonstrate how to solve this issue with one of them. Linear ProbingWhen collision happens, find whether next index has been occupied or not, if not then store data into that index. If it is already occupied, repeat previous process until it finds a slot. Linked listSince data is stored in the form of entry object in HashMap, and an entry contains key, value and next pointer. Therefore we can handle collisions using LinkedList form, that is taking out the original data in this slot and place new data into it and then set the next pointer to the original data, which means the head of the this linkedlist is always the latest data. 3. Implement your HashMap3.1 Map InterfaceThe top interface of HashMap is Map, which means we need our own interface if we want to implement our own map. The map interface of our HashMap is defined as MyMap&lt;K,V&gt; and it should have these three functions: put(K k,V v) get(K k) size() and an internal interface Entry&lt;K,V&gt; It should contains two functions getKey() getValue() Java code:1234567891011121314151617181920212223242526272829303132333435public interface MyMap&lt;K,V&gt; &#123; /** * put function * @param k * @param v * @return */ V put(K k, V v); /** * get function * @param k * @return */ V get(K k); int size(); /** * Entry interface * @param &lt;K&gt; * @param &lt;V&gt; */ interface Entry&lt;K, V&gt;&#123; /** * get the key in an entry object * @return */ K getKey(); /** * get the value in an entry object * @return */ V getValue(); &#125;&#125; 3.2 Implementation of internal class EntryOnce the interface is designed, we need to create a class to implement all its functions. The class MyHashMap is created to implement MyMap interface. An internal class is also necessary for the implementation of internal interface of MyMap. The instance of this internal class is entry, which will be stored into the array. This class should have three global variables, which are K, V and Next pointer. The type of next is entry itself because it points to the next entry object. Java code:123456789101112131415161718192021222324class Entry&lt;K, V&gt; implements MyMap.Entry&lt;K, V&gt; &#123; K k; V v; Entry&lt;K, V&gt; next; public Entry(K k, V v, Entry next) &#123; this.k = k; this.v = v; this.next = next; &#125; @Override public K getKey() &#123; return k; &#125; @Override public V getValue() &#123; return v; &#125; &#125; 3.3 Define global variablesA hashmap contains the following global variables: default length of the array default loading factor an entry array the size of this hashmap 12345678//Default length of the array, initial value is 16private static int defaultLength = 16;//Loading factor, 0.75 by defaultprivate static double defaultLoader = 0.75;//Entry arrayprivate Entry&lt;K, V&gt;[] table = null;//The size of this hashmapprivate int size = 0; 3.4 Define constructorSince the default length and default loading factor can be customized in HashMap, we can define a constructor with array length and loading factor as parameters.1234567891011 /** * customize default array length and loading factor * @param length * @param loader */public MyHashMap(int length, double loader) &#123; defaultLength = length; defaultLoader = loader; //initialize entry array table = new Entry[defaultLength];&#125; If parameters are not specified, we use default value123456/** * use default values */public MyHashMap() &#123; this(defaultLength, defaultLoader);&#125; 3.5 Define hash functionIt is mentioned above that we are using mod method for our hash function. First define an int m, the value of m should be the maximum prime number that is less than the length of its array. I set the value of m to be the length of the array to simplify the algorithm.1234567891011 /** * customize hash algorithm * get the value of index from the hash value of its key, it is the index in which data needs to be stored * @param k * @return */private int getKey(K k) &#123; int m = defaultLength; int index = k.hashCode() % m; return index &gt;= 0 ? index : -index;&#125; 3.6 Implement put functionFirst, we need calculate the index of the array using hash algorithm, and then store the entry object that contains key, value and next pointer to that slot. Before we do that we need to determine if that slot is occupied. It should be handled differently according to the situation. Detailed explanations are given in the comments.123456789101112131415161718192021222324252627public V put(K k, V v) &#123; //calculate the index of a given key int index = getKey(k); Entry&lt;K, V&gt; entry = table[index]; //determine if entry is null if (entry == null) &#123; /* * if entry is null, it means there is no data in this slot * create an entry object * next pointer has no value at this moment because there is only * one entry object in this slot * */ table[index] = new Entry(k, v, null); //size of map + 1 size++; &#125; else &#123; /* * if entry is not null, it means there is at least one entry in * this slot * create an entry object * set the next pointer to be previous entry and replace the data * in the array * */ table[index] = new Entry&lt;K, V&gt;(k, v, entry); &#125; return table[index].getValue(); &#125; 3.7 Implement resize mechanism of HashMapThe principle of resize in hashmap is that when the size of map is greater than default length * loading factor, the length of the array will be doubled and data in the array will be rehashed and restored. Therefore, in previous put function, we need to first determine if the size of hashmap has reach the boundary of resize, and then execute rest of the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//resize of the arrayprivate void expand() &#123; //create an entry array that its length is two times as previous Entry&lt;K, V&gt;[] newTable = new Entry[2 * defaultLength]; //call rehash function rehash(newTable);&#125;//the process of rehashprivate void rehash(Entry&lt;K,V&gt;[] newTable) &#123; //create a list to store all the entry objects in the hashmap List&lt;Entry&lt;K, V&gt;&gt; list = new ArrayList&lt;Entry&lt;K, V&gt;&gt;(); //traverse the array for(int i=0; i&lt;table.length;i++) &#123; //continue if the given slot has no data if (table[i] == null) &#123; continue; &#125; //store all entries into the list using recursive method findEntryByNext(table[i],list); if (list.size() &gt; 0) &#123; //reset size size = 0; //double the default size defaultLength = 2 * defaultLength; table = newTable; for (Entry&lt;K, V&gt; entry : list) &#123; if (entry.next != null) &#123; //set next pointer of all entries to null entry.next = null; &#125; //rehash new table put(entry.getKey(), entry.getValue()); &#125; &#125; &#125;&#125;private void findEntryByNext(Entry&lt;K, V&gt; entry,List&lt;Entry&lt;K, V&gt;&gt; list ) &#123; if (entry != null &amp;&amp; entry.next != null) &#123; list.add(entry); //call recursive function findEntryByNext(entry.next,list); &#125;else &#123; list.add(entry); &#125;&#125; 3.8 Implement get functionAs it is mentioned above, the nature of hash algorithm might lead to the scenario that multiple entries stored in the same index. Therefore, we need to find the real entry object by comparing the key value.123456789101112131415161718192021222324252627282930313233343536public V get(K k) &#123; //get the index that the entry is stored int index = getKey(k); //non-empty check if (table[index] == null) &#123; return null; &#125; //call function to find the real value and then return return findValueByEqualKey(k,table[index]);&#125; /** * find real value by recursive comparison * @param k * @param entry * @return */public V findValueByEqualKey(K k , Entry&lt;K,V&gt; entry) &#123; /* * if key of this parameter equals to the key of this entry, that means * this is the target entry * */ if (k == entry.getKey() || k.equals(entry.getKey())) &#123; return entry.getValue(); &#125; else &#123; /* * if they are not equal, use recursive method to compare the key of its next pointer to find the real value * */ if (entry.next != null) &#123; return findValueByEqualKey(k, entry.next); &#125; &#125; return entry.getValue();&#125; Since the size function is rather easy, all we need to do is return the variable size, I just paste the code here.1234//return the size of the mappublic int size() &#123; return size;&#125; At this point, the basic function of a HashMap is completed. That includes put function, get function and its resize mechanism. In the next section, I will write a test class to test the code see if they are implemented correctly. In the meantime, its performacne needs to be tested as well. 4. Test MyHashMap4.1 Output testWrite a test class to check if the output of our HashMap and the output of HashMap in JDK are the same. 123456789101112131415161718192021222324252627282930313233343536373839/** * @Author: Yiheng Chen * @Description: Map test class * @Date: Created in 4:33 2017/9/1 * @Modified by: */public class MyMapTest &#123; public static void main(String[] args) &#123; MyHashMap&lt;String,String &gt; map = new MyHashMap(); Long t1 = System.currentTimeMillis(); for (int i=0; i&lt;1000;i++) &#123; map.put(\"key\" + i, \"value\" + i); &#125; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"key: \" + \"key\" + i +\"---\"+ \"value: \" + map.get(\"key\" + i)); &#125; Long t2 = System.currentTimeMillis(); System.out.println(\"time consumed by MyHashMap：\"+(t2-t1)); System.out.println(\"-------------------HashMap-------------------------\" ); Map&lt;String,String &gt; hashMap = new HashMap(); Long t3 = System.currentTimeMillis(); for (int i=0; i&lt;1000;i++) &#123; hashMap.put(\"key\" + i, \"value\" + i); &#125; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"key: \" + \"key\" + i + \"---\"+ \"value: \" + hashMap.get(\"key\" + i)); &#125; Long t4 = System.currentTimeMillis(); System.out.println(\"time consumed by HashMap in JDK: \"+(t4-t3)); &#125;&#125; Part of the output:1234567891011121314151617181920key: key980---value: value980key: key981---value: value981key: key982---value: value982key: key983---value: value983key: key984---value: value984key: key985---value: value985key: key986---value: value986key: key987---value: value987key: key988---value: value988key: key989---value: value989key: key990---value: value990key: key991---value: value991key: key992---value: value992key: key993---value: value993key: key994---value: value994key: key995---value: value995key: key996---value: value996key: key997---value: value997key: key998---value: value998key: key999---value: value999 It can be seen that the result of our HashMap is excatly the same as the output of HashMap in JDK. It indicates that our HashMap is successfully implemented. 4.2 Performance testResult of the performance test:123time consumed by MyHashMap：30-----------------------time consumed by HashMap in JDK：19 Without doubt, the HashMap in JDK is obviously more powerful than the one I implemented. The HashMap in JDK may be the most optimized implementation of map. However, the performance of our own HashMap can be considered acceptable, given the simplicity of the code. Thanks for reading.","categories":[],"tags":[]},{"title":"自己动手实现一个HashMap","slug":"自己动手实现一个HashMap","date":"2017-08-26T07:30:39.000Z","updated":"2022-06-11T08:38:55.977Z","comments":true,"path":"2017/08/26/自己动手实现一个HashMap/","link":"","permalink":"https://winnerchen.github.io/2017/08/26/自己动手实现一个HashMap/","excerpt":"1. 前言HashMap作为java数据结构中重要的一员，同时拥有高效的查询和插入的优点。近期在做项目的时候我也是领略到了hashmap的强大之处，hashmap为前后台数据的交互提供了非常高的可扩展性和灵活性。键值对的数据结构也天然对json字符串的转换提供良好的支持。这篇文章主要分析HashMap的原理，以及如何自己实现一个HashMap。","text":"1. 前言HashMap作为java数据结构中重要的一员，同时拥有高效的查询和插入的优点。近期在做项目的时候我也是领略到了hashmap的强大之处，hashmap为前后台数据的交互提供了非常高的可扩展性和灵活性。键值对的数据结构也天然对json字符串的转换提供良好的支持。这篇文章主要分析HashMap的原理，以及如何自己实现一个HashMap。 2. HashMap的原理2.1 什么是HashMap？基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变 ——摘自百度百科。 2.2 什么是HashHash是一种算法，能将一个任意长度的二进制值通过一个映射关系转换成一个固定长度的二进制值。在HashMap中，哈希算法主要是用于根据key的值算出存放数组的index值。HashMap中的存储都是根据key的哈希值有关的。哈希算法又被称为散列的过程，那么什么是散列呢？散列即把数据均匀的存放到数组中的各个位置，从而尽量避免出现多个数据存放在一块区间内。 优秀的哈希算法应该具备以下两点： 保证散列值非常均匀 保证冲突极少出现 哈希函数有很多种，在这里我以除留取余法（取模）为例，首先定义一个数组的长度，假设为16。那么此时的索引为key摸于m，m的取值规则是比数组长度小的最大质数。在这个情况下m为13。由于这种算法会导致这样的情况出现，即不同的key经过哈希运算之后得到了一样的index，如key为2和15的index值都为2，那么此时就需要我们处理冲突了。 Ps. JDK中的hash算法远比这个复杂，在这里我仅仅只是举一个例子方便读者理解。 2.3 处理冲突 线性探测法当冲突产生时，查找下一个索引是否被占用，如果没有，则把数据存到该索引上。 链表形式由于在HashMap中，单个数据是以entry的形式存储的，而entry中包含了key，value和next指针。那么当冲突产生时，我们就把原先存放到这个位置的数据取出来，然后在这个位置存放新的数据，并且把新数据的next指针设为原数据，也就是说链表头位置的数据永远是最新的数据。 3. 实现自己的HashMap3.1 Map接口HashMap的顶层接口是Map，那么我们自己实现的Map也需要一个接口，在这里我定义接口的名称为MyMap&lt;K,V&gt;。这个接口中应该含有的方法包括： put(K k,V v) get(K k) size() 和一个内部接口 Entry&lt;K,V&gt; 这个内部接口中包含两个方法 getKey() getValue() 代码如下1234567891011121314151617181920212223242526272829303132333435public interface MyMap&lt;K,V&gt; &#123; /** * put方法 * @param k * @param v * @return */ V put(K k, V v); /** * get方法 * @param k * @return */ V get(K k); int size(); /** * Entry内部接口 * @param &lt;K&gt; * @param &lt;V&gt; */ interface Entry&lt;K, V&gt;&#123; /** * 根据entry对象获取key值 * @return */ K getKey(); /** * 根据entry对象获取value值 * @return */ V getValue(); &#125;&#125; 3.2 内部类Entry的实现接口设计完毕之后，我们需要创建一个类来实现这个接口的方法。我创建了一个名为MyHashMap的类实现MyMap接口。 这里我们需要一个内部类来实现MyMap的内部接口，内部类的实例对象即数组中存储的entry对象，所以我们需要定义三个成员变量，分别是K，V和Next。next的类型就是entry本身，因为它指向的是下一个entry对象。 内部类代码如下123456789101112131415161718192021222324class Entry&lt;K, V&gt; implements MyMap.Entry&lt;K, V&gt; &#123; K k; V v; Entry&lt;K, V&gt; next; public Entry(K k, V v, Entry next) &#123; this.k = k; this.v = v; this.next = next; &#125; @Override public K getKey() &#123; return k; &#125; @Override public V getValue() &#123; return v; &#125; &#125; 3.3 定义成员变量HashMap中含有以下几个成员变量： 默认数组长度 默认负载因子 Entry数组 HashMap的大小 12345678//默认数组大小，初始大小为16private static int defaultLength = 16;//默认负载因子，为0.75private static double defaultLoader = 0.75;//Entry数组private Entry&lt;K, V&gt;[] table = null;//HashMap的大小private int size = 0; 3.4 定义构造方法在HashMap中默认数组长度和默认负载因子都是可以自定义的，那么我们定义一个可以自定义数组长度和负载因子的构造方法。1234567891011 /** * 自定义默认长度和负载因子 * @param length * @param loader */public MyHashMap(int length, double loader) &#123; defaultLength = length; defaultLoader = loader; //初始化数组 table = new Entry[defaultLength];&#125; 如果不指定数组长度和负载因子则使用默认值123456/** * 使用默认值 */public MyHashMap() &#123; this(defaultLength, defaultLoader);&#125; 3.5定义哈希函数上文已经提过了，哈希函数我们使用除留取余法。定义一个整型m，m的取值应该是一个比数组长度小的最大质数，为了简化算法我取数组的长度作为m的值。以key的哈希值模于m，得到index的值并且返回。 1234567891011 /** * 自定义哈希算法 * 根据key的哈希值得到一个index索引，即存放到数组中的下标 * @param k * @return */private int getKey(K k) &#123; int m = defaultLength; int index = k.hashCode() % m; return index &gt;= 0 ? index : -index;&#125; 最后返回的时候用了一个三元运算符，是为了要确保index的值必须是一个正数。 3.6 实现put方法首先，我们需要通过哈希算法得到数组的下标，然后把一个包含键值对以及next指针的entry对象存到该位置中。 在存入数组之前我们需要判断当前索引中是否已经存在数据。根据不同情况，做出不同的存储处理，代码中的注释有详细的解释。 123456789101112131415161718192021222324public V put(K k, V v) &#123; //根据key和哈希算法算出数组下标 int index = getKey(k); Entry&lt;K, V&gt; entry = table[index]; //判断entry是否为空 if (entry == null) &#123; /* * 如果entry为空，则代表当前位置没有数据。 * new一个entry对象，内部存放key，value。 * 此时next指针没有值，因为这个位置上只有一个entry对象 * */ table[index] = new Entry(k, v, null); //map的大小加1 size++; &#125; else &#123; /* * 如果entry不为空，则代表当前位置已经有数据了 * new一个entry对象，内部存放key，value。 * 把next指针设置为原本的entry对象并且把数组中的数据替换为新的entry对象 * */ table[index] = new Entry&lt;K, V&gt;(k, v, entry); &#125; return table[index].getValue(); &#125; 3.7 实现HashMap的扩容HashMap的扩容机制是：当map的大小大于默认长度*默认负载因子，那么数组的长度会翻倍，数组中的数据会重新散列然后再存放。那么在原先的put方法中，需要先判断是否达到扩容的标准在进行执行下面的代码。如果达到扩容的标准则需要调用扩容的方法。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//数组的扩容private void expand() &#123; //创建一个大小是原来两倍的entry数组 Entry&lt;K, V&gt;[] newTable = new Entry[2 * defaultLength]; //重新散列 rehash(newTable);&#125;//重新散列的过程private void rehash(Entry&lt;K,V&gt;[] newTable) &#123; //创建一个list用于装载HashMap中所有的entry对象 List&lt;Entry&lt;K, V&gt;&gt; list = new ArrayList&lt;Entry&lt;K, V&gt;&gt;(); //遍历整个数组 for(int i=0; i&lt;table.length;i++) &#123; //如果数组中的某个位置没有数据，则跳过 if (table[i] == null) &#123; continue; &#125; //通过递归的方式将所有的entry对象装载到list中 findEntryByNext(table[i],list); if (list.size() &gt; 0) &#123; //把size重置 size = 0; //把默认长度设置为原来的两倍 defaultLength = 2 * defaultLength; table = newTable; for (Entry&lt;K, V&gt; entry : list) &#123; if (entry.next != null) &#123; //把所有entry的next指针置空 entry.next = null; &#125; //对新table进行散列 put(entry.getKey(), entry.getValue()); &#125; &#125; &#125;&#125;private void findEntryByNext(Entry&lt;K, V&gt; entry,List&lt;Entry&lt;K, V&gt;&gt; list ) &#123; if (entry != null &amp;&amp; entry.next != null) &#123; list.add(entry); //递归调用 findEntryByNext(entry.next,list); &#125;else &#123; list.add(entry); &#125;&#125; 因为在put方法中加上了对扩容标准的判断，原先的put方法需要修改1234567891011121314151617181920212223242526272829public V put(K k, V v) &#123; //判断size是否达到扩容的标准 if (size &gt;= defaultLength * defaultLoader) &#123; expand(); &#125; //根据key和哈希算法算出数组下标 int index = getKey(k); Entry&lt;K, V&gt; entry = table[index]; //判断entry是否为空 if (entry == null) &#123; /* * 如果entry为空，则代表当前位置没有数据。 * new一个entry对象，内部存放key，value。 * 此时next指针没有值，因为这个位置上只有一个entry对象 * */ table[index] = new Entry(k, v, null); size++; &#125; else &#123; /* * 如果entry不为空，则代表当前位置已经有数据了 * new一个entry对象，内部存放key，value。 * 把next指针设置为原本的entry对象并且把数组中的数据替换为新的entry对象 * */ table[index] = new Entry&lt;K, V&gt;(k, v, entry); &#125; return table[index].getValue();&#125; 3.8 实现get方法上文提到了，由于hash算法可能会导致相同的索引中包含了不同的entry对象，我们需要通过对比key值的方式来找到我们真正要的那个entry对象。代码如下：1234567891011121314151617181920212223242526272829303132333435363738public V get(K k) &#123; //获取此key对应的entry对象所存放的索引index int index = getKey(k); //非空判断 if (table[index] == null) &#123; return null; &#125; //调用方法找到真正的value值并返回。 return findValueByEqualKey(k,table[index]);&#125; /** * * 通过递归比较key值的方式找到真正我们要找的value值 * @param k * @param entry * @return */public V findValueByEqualKey(K k , Entry&lt;K,V&gt; entry) &#123; /* * 如果传进来的key等于这个entry的key值，说明这个就是我们要找的entry对象 * 那么直接返回这个entry的value * */ if (k == entry.getKey() || k.equals(entry.getKey())) &#123; return entry.getValue(); &#125; else &#123; /* * 如果不相等，说明这个不是我们要找的entry对象， * 通过递归的方式去比较它的next指针中的entry的key值，来找到真正的entry对象 * */ if (entry.next != null) &#123; return findValueByEqualKey(k, entry.next); &#125; &#125; return entry.getValue();&#125; 由于size方法非常简单，直接返回size即可，我直接贴一下代码1234//返回HashMap的大小public int size() &#123; return size;&#125; 到了这里，HashMap的基本功能已经都写完了，包括put方法、get方法和扩容机制。那么下面我们来测试一下看看自己写的map能否实现功能。 4. 测试MyHashMap写一个测试类，对比一下我们的HashMap和jdk自带的HashMap，看看输出是否一样。 测试类代码 123456789101112131415161718192021222324252627282930313233343536373839/** * @Author: Yiheng Chen * @Description: Map测试类 * @Date: Created in 4:33 2017/9/1 * @Modified by: */public class MyMapTest &#123; public static void main(String[] args) &#123; MyHashMap&lt;String,String &gt; map = new MyHashMap(); Long t1 = System.currentTimeMillis(); for (int i=0; i&lt;1000;i++) &#123; map.put(\"key\" + i, \"value\" + i); &#125; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"key: \" + \"key\" + i +\"---\"+ \"value: \" + map.get(\"key\" + i)); &#125; Long t2 = System.currentTimeMillis(); System.out.println(\"MyHashMap耗时：\"+(t2-t1)); System.out.println(\"-------------------HashMap-------------------------\" ); Map&lt;String,String &gt; hashMap = new HashMap(); Long t3 = System.currentTimeMillis(); for (int i=0; i&lt;1000;i++) &#123; hashMap.put(\"key\" + i, \"value\" + i); &#125; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"key: \" + \"key\" + i + \"---\"+ \"value: \" + hashMap.get(\"key\" + i)); &#125; Long t4 = System.currentTimeMillis(); System.out.println(\"JDK的HashMap耗时：\"+(t4-t3)); &#125;&#125; 部分结果的截取：1234567891011121314151617181920key: key980---value: value980key: key981---value: value981key: key982---value: value982key: key983---value: value983key: key984---value: value984key: key985---value: value985key: key986---value: value986key: key987---value: value987key: key988---value: value988key: key989---value: value989key: key990---value: value990key: key991---value: value991key: key992---value: value992key: key993---value: value993key: key994---value: value994key: key995---value: value995key: key996---value: value996key: key997---value: value997key: key998---value: value998key: key999---value: value999 可以发现MyHashMap的输出和JDK的HashMap是完全一样的，那么说明了这个自己实现的HashMap功能已经基本实现。 然后我又在这个基础上测试了一下耗时，结果如下：123MyHashMap耗时：30-----------------------JDK的HashMap耗时：19 性能上自然是JDK的HashMap更强大，这个毋庸置疑，JDK中的HashMap可以说是最优化的map实现了，我们自己实现的肯定不如人家的。但是这个性能已经是不错的了。 至此，我们已经完整的实现了一个自己的HashMap，希望这篇文章对你有帮助。","categories":[],"tags":[]},{"title":"Hexo+Node.js+GitHub搭建自己的个人博客","slug":"Hexo-Node-js-GitHub搭建自己的个人博客","date":"2017-08-11T06:18:17.000Z","updated":"2022-06-11T08:38:55.970Z","comments":true,"path":"2017/08/11/Hexo-Node-js-GitHub搭建自己的个人博客/","link":"","permalink":"https://winnerchen.github.io/2017/08/11/Hexo-Node-js-GitHub搭建自己的个人博客/","excerpt":"1. 前言作为一名技术人员，很早之前就想搭建一个自己的个人博客了，但是由于种种原因一直搁置着，最近终于闲了下来，有时间去慢慢折腾了。拥有自己的个人博客是有很多好处的，包括： 总结自己的学习和成长 记录自己对于各种技术的收获 共享知识，方便其他人学习 包装自己，展示自我 练习文笔 … 还有很多的好处就不一一描述了，相信大家都有各种各样的动力去做一个博客。相对于早期的博客开发来说，现在搭建自己的个人博客是一件相对容易的事情，很多的框架和技术都已经把复杂的流程和操作封装起来，准备好环境之后只需要几条命令行即可完成本地博客的搭建。新博文的发布和编辑也是很好上手的。","text":"1. 前言作为一名技术人员，很早之前就想搭建一个自己的个人博客了，但是由于种种原因一直搁置着，最近终于闲了下来，有时间去慢慢折腾了。拥有自己的个人博客是有很多好处的，包括： 总结自己的学习和成长 记录自己对于各种技术的收获 共享知识，方便其他人学习 包装自己，展示自我 练习文笔 … 还有很多的好处就不一一描述了，相信大家都有各种各样的动力去做一个博客。相对于早期的博客开发来说，现在搭建自己的个人博客是一件相对容易的事情，很多的框架和技术都已经把复杂的流程和操作封装起来，准备好环境之后只需要几条命令行即可完成本地博客的搭建。新博文的发布和编辑也是很好上手的。 选择一个自己喜欢的主题风格即可让自己的博客看起来有模有样的了，以下是搭建博客的准备工作。 2. 搭建环境准备 Node.js的安装和准备 Git的安装和准备 GitHub账号的配置和仓库的新建2.1 下载Node.js的安装文件Node.js下载链接： Windows Installer 32-bit Windows Installer 64-bit 大家可以根据自己的windows版本下载安装相应的文件。 下载完毕之后，一路按next即可完成安装。 然后我们检查一下组件是否安装完毕，按下Win+R输入CMD打开命令行窗口。在打开的命令行窗口中输入 12node -vnpm -v 如果显示如下图，则表示安装正确，可以进行下一步安装。 2.2 配置Git环境下载Git安装文件 下载完成之后直接安装即可，安装过程无需解释了，next到结束即可。 安装完毕之后用命令来检查Git是否已经正确安装:1git --version 如果结果如下图所示，则说明安装正确，进入下一步安装。 2.3 GitHub账号的注册和配置2.3.1 GitHub账号的注册前往GitHub注册页面注册自己的个人账户 2.3.2 GitHub仓库的创建如下图所示，点击Your Profile - Repositories - New来创建新仓库 在repository内填写yourname.github.io,如下图所示 2.3.3 仓库配置如果仓库正确创建之后，你会看到如下界面：然后点击setting选项卡，进入设置页面，往下拖至GitHub Pages项，此时可以看到Source下的选项不可用，因为此时尚未有分支创建和代码提交。如下图所示。在完成了hexo的安装、测试以及代码推送之后，可以选择master分支将自己的博客代码部署到GitHub服务器上。下面介绍Hexo的安装和配置。 2.4 安装Hexo首先新建一个文件夹，作为你的本地博客网站的路径。我的路径是F:/hexo。在该文件夹下按住Shift键+右键，选择‘在此处打开命令窗口’，进入cmd命令行。在命令行中输入12npm install hexo -g #-g表示全局安装, npm默认为当前项目安装hexo version 如果遇到报错，则用下面命令安装1npm install hexo --no-optional 使用1hexo v 来查看hexo是否已经正确安装，如果显示下图，则表明安装成功。 3. 部署本地博客然后依次输入hexo命令：1234hexo init #执行init命令初始化到你指定的hexo目录npm install #install before start blogginghexo generate #自动根据当前目录下文件,生成静态网页hexo server #运行本地服务 显示下图则表示项目已经成功初始化并且部署到本地4000端口。在浏览器中输入http://localhost:4000/即可访问本地博客。 4. 把本地博客部署到GitHub Pages4.1 在Git中配置个人信息如果你之前已经配置好Git的个人信息，可以跳过这一步。查看Git是否关联GitHub：在该文件夹下右击打开GIT bash窗口，然后输入1ssh -T git@github.com 如果显示如下图，则表示已经关联成功如果是初次使用git要首先设置git的username和email：12git config --global user.name &quot;your_username&quot;git config --global user.email &quot;your_email@xxx.com&quot; 然后生成秘钥1ssh-keygen -t rsa -C &quot;your_email@xxx.com&quot; 连续按三次回车之后，会生成两个文件id_rsa 和 id_rsa.pub，id_rsa 是密钥，id_rsa.pub 就是公钥。这两文件默认分别在如下目录里生成： Linux/Mac 系统 在 ~/.ssh 下，win系统在 /c/Documents and Settings/username/.ssh 下，都是隐藏文件，相信你们有办法查看的。 接下来要做的是把 id_rsa.pub 的内容添加到 GitHub 上，这样你本地的 id_rsa 密钥跟 GitHub上的 id_rsa.pub 公钥进行配对，授权成功才可以提交代码。 4.2 GitHub上添加SSH key第一步先在 GitHub 上的设置页面，点击最左侧 SSH and GPG keys ：然后点击右上角的 New SSH key 按钮， 然后将id_rsa.pub公钥文件里的内容复制粘贴进去就可以了。Title那一栏可以不用填写。点击Add SSH key 按钮就ok了。SSH key 添加成功之后，输入 ssh -T git@github.com 进行测试，如果出现以下提示证明添加成功了。 4.3 配置_config.yml文件在根目录下找到_config.yml文件，找到deployment，然后按照如下修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 比如我的仓库的地址是git@github.com:winnerchen/chen.github.io.git，所以配置如下1234deploy: type: git repo: git@github.com:winnerchen/chen.github.io.git branch: master 同时还可在site栏下修改标题已经作者：1234567# Sitetitle: Your Blog Namesubtitle: Your Subtitledescription:author: Your Namelanguage:timezone: 配置url和root（非常重要！如果没有配置成功会显示不出样式和主题！）：123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults: 以我的配置为例：1234url: https://winnerchen.github.io #博客的域名root: /chen.github.io #git仓库的名称permalink: :year/:month/:day/:title/permalink_defaults: 4.4部署到GitHub Pages安装git扩展：1npm install hexo-deployer-git --save 如果没有执行者行命令，将会提醒1deloyer not found:git 运行生成和部署的命令：12hexo g # 生成hexo d # 部署 显示下图表明项目已经成功推送到github远程仓库此时到github仓库中查看，会发现代码已经成功上传然后进入setting中，找到github pages，把source选为master branch稍等一分钟左右，等到刷出如下图所示的页面即可访问自己部署在github上的个人博客了！ 至此，在github上部署个人博客的教程已经结束，希望大家都不出bug顺利走完！ 5.发布日志To be continued… 6.自定义主题To be continued… 7.插件安装To be continued…","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://winnerchen.github.io/categories/搭建博客/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://winnerchen.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://winnerchen.github.io/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://winnerchen.github.io/tags/个人博客/"},{"name":"Node.js","slug":"Node-js","permalink":"https://winnerchen.github.io/tags/Node-js/"}]},{"title":"搬瓦工+SS+FS搭建自己的翻墙神器","slug":"搬瓦工-ss-fs搭建自己的私人服务器","date":"2017-08-09T06:49:17.000Z","updated":"2022-06-11T08:38:55.977Z","comments":true,"path":"2017/08/09/搬瓦工-ss-fs搭建自己的私人服务器/","link":"","permalink":"https://winnerchen.github.io/2017/08/09/搬瓦工-ss-fs搭建自己的私人服务器/","excerpt":"前言作为一个经常上谷歌，YouTube的程序狗，不能自由的访问网络实在是让我很心烦，以前我都是买网上的vpn服务，但是由于不知名的原因，那个网站被封掉了… 购买vpn服务其实也有很多的弊端，例如数据有泄漏的隐患、网络高峰期速度会比较慢，还有就是vpn的费用比起整年购买的vps服务也是贵了不少。 前两天有一个哥们推荐了这么一个翻墙的神技，根据相应的关键字我百度了一番教程之后，终于被我摸索出一套可行的方案。下面是很详细的教程，希望新手们在走完教程后能享受到自由无限制的网络:)","text":"前言作为一个经常上谷歌，YouTube的程序狗，不能自由的访问网络实在是让我很心烦，以前我都是买网上的vpn服务，但是由于不知名的原因，那个网站被封掉了… 购买vpn服务其实也有很多的弊端，例如数据有泄漏的隐患、网络高峰期速度会比较慢，还有就是vpn的费用比起整年购买的vps服务也是贵了不少。 前两天有一个哥们推荐了这么一个翻墙的神技，根据相应的关键字我百度了一番教程之后，终于被我摸索出一套可行的方案。下面是很详细的教程，希望新手们在走完教程后能享受到自由无限制的网络:) 1.搬瓦工1.1注册·传送门：https://bwh1.net/register.php 需要提一句的是，在注册的时候，如果是国内的网络会显示不出验证码。不过相信这种问题一定难不倒机智的你。 1.2 购买服务作为个人用户，我推荐大家还是买第一个服务即可，不做为商业服务器部署项目的话，每个月的500个G的流量是非常够用的。一年下来大概36美金。 1.3 服务管理根据下图即可跳转到管理界面 主管理界面：注意这里记录了你的ip地址和端口号，之后FS和SS的客户端会需要这些数据。 2. ShadowSocks2.1 配置服务器端SS服务器端的配置非常简单，因为搬瓦工已经帮我们一键集成了，我们需要做的就是开启这个服务。具体流程参考下图。 在屏幕的左边点击Shadowsocks Server，第一次进入会提示你未开启该服务，是否需要现在开启。直接点激活即可。 激活完毕之后就会跳转到这个界面，SS服务器端口号和密码需要记录下来，客户端需要使用。 2.2 配置客户端推荐使用版本：2.5.8根据上图配置SS客户端的ip地址，端口号。密码从搬瓦工网上复制下来。端口号2000是本地端口，用于加速使用，可以随意填写。 3. FinalSpeed3.1 配置服务器端打开搬瓦工的linux命令行，点击右边导航栏的Root-shell basic进入。在命令行中依次输入：1yum -y install wget 1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/finalspeed/master/install_fs.sh &amp;&amp; bash install_fs.sh 顺利安装好FS的服务端之后即可输入启动命令来启动FS服务1/etc/init.d/finalspeed start FS相关命令停止FS服务端：1/etc/init.d/finalspeed stop 查看FS运行状态1/etc/init.d/finalspeed status 3.2 配置客户端推荐版本：FinalSpeed1.2详细配置参见下图如果连接成功会提示已成功连接 如果一切顺利，至此一切配置都已配完，是时候享受自由无限制的网络了！","categories":[],"tags":[]},{"title":"IDEA5分钟，Eclipse2小时","slug":"IDEA5分钟，Eclipse2小时","date":"2017-08-06T11:30:51.000Z","updated":"2022-06-11T08:38:55.970Z","comments":true,"path":"2017/08/06/IDEA5分钟，Eclipse2小时/","link":"","permalink":"https://winnerchen.github.io/2017/08/06/IDEA5分钟，Eclipse2小时/","excerpt":"IDEA概述1.1 Java开发人员常用IDE1.1.1 什么是IDEIDE（Integrated [ˈɪntɪgreɪtɪd] Development Environment）-集成开发环境。是用于提供程序开发环境的应用程序，一般包括代码编辑器，编译器，调试器和图形用户操作等工具。 —-来源于百度百科 1.1.2 Java开发人员常用IDEEclipse,MyEclipse, IntelliJ IDEA","text":"IDEA概述1.1 Java开发人员常用IDE1.1.1 什么是IDEIDE（Integrated [ˈɪntɪgreɪtɪd] Development Environment）-集成开发环境。是用于提供程序开发环境的应用程序，一般包括代码编辑器，编译器，调试器和图形用户操作等工具。 —-来源于百度百科 1.1.2 Java开发人员常用IDEEclipse,MyEclipse, IntelliJ IDEA 1.2、IDEA简介IDEA 全称IntelliJ IDEA，是java语言开发的集成环境。IDEA是JetBrains公司的产品。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查方面。 了解：JetBrains公司开发的所有工具。 1.3、IDEA与Eclipse","categories":[{"name":"IDE工具","slug":"IDE工具","permalink":"https://winnerchen.github.io/categories/IDE工具/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://winnerchen.github.io/tags/IDEA/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://winnerchen.github.io/tags/JetBrains/"},{"name":"开发工具","slug":"开发工具","permalink":"https://winnerchen.github.io/tags/开发工具/"}]},{"title":"Git:从零开始","slug":"Git-从零开始","date":"2017-08-06T10:27:00.000Z","updated":"2022-06-11T08:38:55.969Z","comments":true,"path":"2017/08/06/Git-从零开始/","link":"","permalink":"https://winnerchen.github.io/2017/08/06/Git-从零开始/","excerpt":"初识GitHub1. 什么是GitHubGitHub是一个面向开源及私有软件项目的托管平台,它只支持git这一种版本管理技术,故名GitHub。对于大部分用户来说，GitHub是一个托管代码的地方，用于备份其本地仓库的代码。 2.GitHub和Git的区别本人刚开始学习编程的时候也分不清两者的区别，以为GitHub就是Git，但是它们其实是有本质上的区别的。","text":"初识GitHub1. 什么是GitHubGitHub是一个面向开源及私有软件项目的托管平台,它只支持git这一种版本管理技术,故名GitHub。对于大部分用户来说，GitHub是一个托管代码的地方，用于备份其本地仓库的代码。 2.GitHub和Git的区别本人刚开始学习编程的时候也分不清两者的区别，以为GitHub就是Git，但是它们其实是有本质上的区别的。 Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是大名鼎鼎的Linux发明者Linus Torvalds 开发的。不管是想要学习GitHub，还是从事编程相关行业的工作，git都是一门必须要学习的技术，所以从现在开始学习和了解git技术吧！ 而GitHub已经在上面介绍过了，是一个基于git技术的版本托管平台。所以Git知识GitHub上面用来管理项目的一个工具而已，而GitHub的功能则远比这个强大。 3. GitHub 有什么用 学习优秀的开源项目 开源社区一直有一句流行的话叫「不要重复发明轮子」，某种意义上正是因为开源社区的贡献，我们的软件开发才能变得越来越容易，越来越快速。试想你在做项目时，如果每一模块都要自己去写，如网络库、图片加载库、ORM库等等，自己写的好不好是一回事，时间与资源是很大的成本。对于大公司可能会有人力与资源去发明一套自己的轮子，但是对于大部分互联网创业公司来说时间就是一切。而且你在使用开源项目的过程也可以学习他们优秀的设计思想、实现方式，这是最好的学习资料，也是一份提升自己能力的绝佳方式！ 多人协作 如果你想发起一个项目，比如翻译一份不错的英文文档，觉得一个人的精力不够，所以你需要更多的人参与进来，这时候 GitHub是你的最佳选择，感兴趣的人可以参与进来，利用业余时间对这个项目做贡献，然后可以互相审核、合并，简直不要太棒！ 搭建博客、个人网站或者公司官网 这个就不用多说了，现在越来越多的博客都是基于 GitHub Pages来搭建的了，你可以随心所欲的定制自己的样式，可以给你博客买个逼格高的域名，再也不用忍受各大博客网站的约束与各式各样的广告了！ 写作 如果你喜欢写作，而且基于 Markdown， 并准备出版书籍，那么推荐你用 Gitbook ，技术写作人的最爱！ 个人简历 如果你有一个活跃的 GitHub账号，上面有自己不错的开源项目，还经常给别的开源项目提问题，push 代码，那么你找工作将是一个非常大的优势，现在程序员的招聘很多公司都很看中你 GitHub 账号，某种意义上 GitHub就可以算是你的简历了。而且不仅国内，很多国外的科技公司都会通过 GitHub 来寻找优秀的人才。 GIT快速入门关于GitHub的介绍就到这里了，本篇文章的目的是让读者能快速入门Git，运用Git命令行操作本地仓库，并同步到远程仓库。下文会先介绍一些最基本的Git知识和常用的Git操作。 1. 什么是Git上文说了，Git是一款新时代的版本控制工具，那么版本控制到底是什么意思呢？如何去理解版本控制工具呢？下面几个例子大家可以思考一下。 在软件开发中，源代码是最重要的，那么对于源代码的管理也就非常重要： 比如为了防止代码的丢失，肯定本地机器与远程服务器都要存放一份，而且还需要有一套机制让本地可以跟远程同步； 又比如我们经常是好几个人做同一个项目，都要对一份代码做更改，这个时候需要大家互不影响，又需要各自可以同步别人的代码； 又比如我们开发的时候免不了有bug，有时候刚发布的功能就出现了严重的bug，这个时候需要紧急对代码进行还原； 又比如随着我们版本迭代的功能越来越多，但是我们需要清楚的知道历史每一个版本的代码更改记录，甚至知道每个人历史提交代码的情况； 等等等类似以上的情况，这些都是版本控制系统能解决的问题。所以说，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，对于软件开发领域来说版本控制是最重要的一环，而 Git 毫无疑问是当下最流行、最好用的版本控制系统。 2. Git安装上面说了，Git 是一个版本控制系统，你也可以理解成是一个工具，跟 Java 类似，使用之前必须得先下载安装，所以第一步必须要安装，我用的是 Mac ， Mac 上其实系统自带 Git 的，不过这里统一提供一下各平台的安装方式，这部分就不过多介绍，相信大家这里搞的定。 Mac：https://sourceforge.net/projects/git-osx-installer/ Windows：https://git-for-windows.github.io/ Linux：apt-get install git","categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://winnerchen.github.io/categories/GitHub/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://winnerchen.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://winnerchen.github.io/tags/GitHub/"},{"name":"版本控制","slug":"版本控制","permalink":"https://winnerchen.github.io/tags/版本控制/"},{"name":"代码托管","slug":"代码托管","permalink":"https://winnerchen.github.io/tags/代码托管/"}]},{"title":"Markdown基础教程","slug":"Markdown基础教程","date":"2017-08-06T07:39:48.000Z","updated":"2022-06-11T08:38:55.970Z","comments":true,"path":"2017/08/06/Markdown基础教程/","link":"","permalink":"https://winnerchen.github.io/2017/08/06/Markdown基础教程/","excerpt":"1. 标题为了获得上面的 “1. 标题”， 在 Markdown 编辑器里输入： 1# 1. 标题 “#” 后最好加个空格。除此之外，还有 5 级标题，依次有不同的字体大小，即 12345## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这样就有：","text":"1. 标题为了获得上面的 “1. 标题”， 在 Markdown 编辑器里输入： 1# 1. 标题 “#” 后最好加个空格。除此之外，还有 5 级标题，依次有不同的字体大小，即 12345## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这样就有： 二级标题三级标题四级标题五级标题六级标题 2. 加粗，斜体最常用的强调方式，那就是 加粗 了，你得这样： 1最常用的强调方式，那就是 **加粗** 了，你得这样： 通常我喜欢在 “**加粗的部分**” 旁边各加一个空格，当然你也可以不这样。斜体则多用在于书名，比如：我从来没看过 Jane Eyre 1斜体则多用在于书名，比如：我从来没看过 *Jane Eyre* 但中文的斜体我觉得真是不美，像：《简 · 爱》，一般还是别用了。 3. 层次比如写个读书笔记，你得 第一章 第一节 第二节(你不用敲 “2”，自动就有了） 第一小节（推荐每层次缩进四个空格） 小小节 1 小小节 2 第二小节 也不难： 12345678#### 第一章1. 第一节* 第二节(你不用敲 &quot;2&quot;，自动就有了） * 第一小节（推荐每层次缩进四个空格） * 小小节 1 * 小小节 2 * 第二小节 “*” 后面要加空格，这是必须的，除了 *，还可以使用 + 或者 -。 如果格式出现问题，多加个空行，一般就好了。 4. 链接，图片你：我没读过 Jane Eyre我：以后别跟我说话！你：。。。我：我也没读过，但是， Jane Eyre is not just Jane Eyre 12我：我也没读过，但是， [***Jane Eyre***](http://book.douban.com/subject/1141406/) is not just ***Jane Eyre***![](http://img3.douban.com/mpic/s1108264.jpg) 5. 其他你可能还没注意到本文每部分之间的分割线和 其他 的链接其实没有链接我爱 分割线， 我爱 链接，哪怕它只有颜色~ 12345678---# [5. 其他][null-link]你可能还没注意到本文每部分之间的分割线和 `其他` 的链接其实没有链接我爱 `分割线`， 我爱 [**链接**][null-link]，哪怕它只有颜色~[null-link]: chrome://not-a-link “---” 的上下最好各空一行 P.S. 补充一种高端的链接: [鼠标移过来，先别单击 ~][hover][hover]: http://www.google.com.sg “Google Sg 更快，更好用。好，现在单击吧” 代码如下： 12**P.S.** 补充一种高端的链接: [鼠标移过来，**先别单击** ~][hover][hover]: http://www.google.com.sg &quot;Google Sg 更快，更好用。好，现在单击吧&quot; （可惜 Google 被墙了） P.P.S. 图片链接：(点击图片可跳转）[![][jane-eyre-pic]][jane-eyre-douban][jane-eyre-pic]: http://img3.douban.com/mpic/s1108264.jpg[jane-eyre-douban]: http://book.douban.com/subject/1141406/ 代码如下：123[![][jane-eyre-pic]][jane-eyre-douban][jane-eyre-pic]: http://img3.douban.com/mpic/s1108264.jpg[jane-eyre-douban]: http://book.douban.com/subject/1141406/ 作者：Gnat","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://winnerchen.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://winnerchen.github.io/tags/Markdown/"},{"name":"文本编辑","slug":"文本编辑","permalink":"https://winnerchen.github.io/tags/文本编辑/"}]},{"title":"Hello Hexo","slug":"Hello-Hexo","date":"2017-08-06T05:58:32.000Z","updated":"2022-06-11T08:38:55.970Z","comments":true,"path":"2017/08/06/Hello-Hexo/","link":"","permalink":"https://winnerchen.github.io/2017/08/06/Hello-Hexo/","excerpt":"","text":"HelloThis is my first article:)","categories":[],"tags":[{"name":"未分类","slug":"未分类","permalink":"https://winnerchen.github.io/tags/未分类/"}]}]}